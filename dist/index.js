function setup(e){const t=isConfigValid(e);if(!0!==t)throw new Error(`Options are invalid! ${t[0].message}`);return config=e,vosk.setLogLevel(config.voskLogLevel),model=new vosk.Model(config.modelPath||process.cwd()+"/model"),STTEmitter=new STTOutputEmitter,STTEmitter}function startListeningUser(e,t){if(listeningList[e])return"WARN_ALREADY_LISTENING";const i=new vosk.Recognizer({model:model,sampleRate:16e3}),n=new wav.Reader;n.on("format",async({audioFormat:r,sampleRate:o,channels:s})=>{if(1!=r||1!=s)throw new Error("Audio data must be WAV format mono PCM.");for await(const r of(new Readable).wrap(n)){const n=i.acceptWaveform(r);if(n){const n=i.result();n.text&&STTEmitter.emit("recognition",e,n.text,t.channel.guild,t.channel,t)}}i.free()});const r=new lame.Encoder({channels:2,bitDepth:16,sampleRate:48e3,bitRate:128,outSampleRate:16e3,mode:lame.MONO}),o=t.receiver.createStream(e,{mode:"pcm",end:"manual"});listeningList[e]={discordAudio:o,PCMToMP3:r,wavReader:n,rec:i,connection:t};const s=ffmpeg().input(r).toFormat("wav").on("error",t=>{console.log("PCM > WAV, An error occurred for user",e,t.message)}).on("end",()=>{listeningList[e]=void 0});return s.pipe(n,{highWaterMark:4096}),o.pipe(r,{highWaterMark:4096}),!0}function stopListeningUser(e){return listeningList[e]?(listeningList[e].discordAudio.end(),listeningList[e]=void 0,!0):"WARN_NOT_LISTENING_ALREADY"}const{Readable:Readable,Writable:Writable}=require("stream"),wav=require("wav"),EventEmitter=require("events"),vosk=require("vosk"),ffmpeg=require("fluent-ffmpeg"),lame=require("@suldashi/lame");class STTOutputEmitter extends EventEmitter{}let STTEmitter,model,config={},listeningList={};const{isConfigValid:isConfigValid}=require("./util/validator");exports.setup=setup,exports.startListeningUser=startListeningUser,exports.stopListeningUser=stopListeningUser;